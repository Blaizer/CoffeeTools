// File generated by dotnet-combine at 2025-08-22__00_58_51

//using DiffPatch.Core;
//using DiffPatch.Data;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;



// DiffLineHelper.cs

//namespace DiffPatch
//{
    class DiffLineHelper
    {
        public static string GetContent(string line)
        {
            string content = line.Substring(1);
            return content;
        }
    }
//}


// DiffParser.cs

//namespace DiffPatch
//{
    internal class DiffParser
    {
        const string noeol = "\\ No newline at end of file";
        const string devnull = "/dev/null";

        private delegate void ParserAction(string line, Match m);

        private List<FileDiff> files = new List<FileDiff>();
        private int in_del, in_add;

        private Chunk current = null;
        private FileDiff file = null;

        private int oldStart, newStart;
        private int oldLines, newLines;

        private readonly HandlerCollection schema;

        public DiffParser()
        {
            schema = new HandlerCollection
            {
                    { @"^diff\s", Start },
                    { @"^new file mode \d+$", NewFile },
                    { @"^deleted file mode \d+$", DeletedFile },
                    { @"^index\s[\da-zA-Z]+\.\.[\da-zA-Z]+(\s(\d+))?$", Index },
                    { @"^---\s", FromFile },
                    { @"^\+\+\+\s", ToFile },
                    { @"^@@\s+\-(\d+),?(\d+)?\s+\+(\d+),?(\d+)?\s@@", Chunk },
                    { @"^-", DeleteLine },
                    { @"^\+", AddLine },
                    { @"^Binary files (.+) and (.+) differ", BinaryDiff }

            };
        }

        public IEnumerable<FileDiff> Run(IEnumerable<string> lines)
        {
            foreach (var line in lines)
                if (!ParseLine(line))
                    ParseNormalLine(line);

            return files;
        }

        private void Start(string line)
        {
            file = new FileDiff();
            files.Add(file);

            if (file.To == null && file.From == null)
            {
                var fileNames = ParseFileNames(line);

                if (fileNames != null)
                {
                    file.From = fileNames[0];
                    file.To = fileNames[1];
                }
            }
        }

        private void Restart()
        {
            if (file == null || file.Chunks.Count != 0)
                Start(null);
        }

        private void NewFile()
        {
            Restart();
            file.Type = FileChangeType.Add;
            file.From = devnull;
        }

        private void DeletedFile()
        {
            Restart();
            file.Type = FileChangeType.Delete;
            file.To = devnull;
        }

        private void Index(string line)
        {
            Restart();
            file.Index = line.Split(' ').Skip(1);
        }

        private void FromFile(string line)
        {
            Restart();
            file.From = ParseFileName(line);
        }

        private void ToFile(string line)
        {
            Restart();
            file.To = ParseFileName(line);
        }

        private void BinaryDiff()
        {
            Restart();
            file.Type = FileChangeType.Modified;
        }

        private void Chunk(string line, Match match)
        {
            in_del = oldStart = int.Parse(match.Groups[1].Value);
            oldLines = match.Groups[2].Success ? int.Parse(match.Groups[2].Value) : 0;
            in_add = newStart = int.Parse(match.Groups[3].Value);
            newLines = match.Groups[4].Success ? int.Parse(match.Groups[4].Value) : 0;
            ChunkRangeInfo rangeInfo = new ChunkRangeInfo(
                new ChunkRange(oldStart, oldLines),
                new ChunkRange(newStart, newLines)
            );

            current = new Chunk(line, rangeInfo);
            file.Chunks.Add(current);
        }

        private void DeleteLine(string line)
        {
            string content = DiffLineHelper.GetContent(line);
            current.Changes.Add(new LineDiff(type: LineChangeType.Delete, index: in_del++, content: content));
            file.Deletions++;
        }

        private void AddLine(string line)
        {
            string content = DiffLineHelper.GetContent(line);
            current.Changes.Add(new LineDiff(type: LineChangeType.Add, index: in_add++, content: content));
            file.Additions++;
        }


        private void ParseNormalLine(string line)
        {
            if (file == null) return;

            if (string.IsNullOrEmpty(line)) return;

            string content = DiffLineHelper.GetContent(line);
            current.Changes.Add(new LineDiff(
                oldIndex: line == noeol ? 0 : in_del++,
                newIndex: line == noeol ? 0 : in_add++,
                content: content));
        }

        private bool ParseLine(string line)
        {
            foreach (var p in schema)
            {
                var m = p.Expression.Match(line);
                if (m.Success)
                {
                    p.Action(line, m);
                    return true;
                }
            }

            return false;
        }

        private static string[] ParseFileNames(string s)
        {
            if (string.IsNullOrEmpty(s)) return null;
            return s
                .Split(' ')
                .Reverse().Take(2).Reverse()
                .Select(fileName => Regex.Replace(fileName, @"^(a|b)\/", "")).ToArray();
        }

        private static string ParseFileName(string s)
        {
            s = s.TrimStart('-', '+');
            s = s.Trim();

            // ignore possible time stamp
            var t = new Regex(@"\t.*|\d{4}-\d\d-\d\d\s\d\d:\d\d:\d\d(.\d+)?\s(\+|-)\d\d\d\d").Match(s);
            if (t.Success)
            {
                s = s.Substring(0, t.Index).Trim();
            }

            // ignore git prefixes a/ or b/
            return Regex.IsMatch(s, @"^(a|b)\/")
                ? s.Substring(2)
                : s;
        }

        private class HandlerRow
        {
            public HandlerRow(Regex expression, Action<string, Match> action)
            {
                Expression = expression;
                Action = action;
            }

            public Regex Expression { get; }

            public Action<string, Match> Action { get; }
        }

        private class HandlerCollection : IEnumerable<HandlerRow>
        {
            private List<HandlerRow> handlers = new List<HandlerRow>();

            public void Add(string expression, Action action)
            {
                handlers.Add(new HandlerRow(new Regex(expression), (line, m) => action()));
            }

            public void Add(string expression, Action<string> action)
            {
                handlers.Add(new HandlerRow(new Regex(expression), (line, m) => action(line)));
            }

            public void Add(string expression, Action<string, Match> action)
            {
                handlers.Add(new HandlerRow(new Regex(expression), action));
            }

            public IEnumerator<HandlerRow> GetEnumerator()
            {
                return handlers.GetEnumerator();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return handlers.GetEnumerator();
            }
        }
    }
//}


// DiffParserHelper.cs

//namespace DiffPatch
//{
    public static class DiffParserHelper
    {
        public static IEnumerable<FileDiff> Parse(string input)
        {
            if (string.IsNullOrWhiteSpace(input))
                return Enumerable.Empty<FileDiff>();

            IEnumerable<string> lines = StringHelper.SplitLines(input);

            if (!lines.Any())
                return Enumerable.Empty<FileDiff>();

            var parser = new DiffParser();

            return parser.Run(lines);
        }
    }
//}


// FileDiffHelper.cs

//namespace DiffPatch
//{
    public class FileDiffHelper
    {
        private delegate void ParserAction(string line, Match m);

        public static IEnumerable<FileDiff> Parse(string input)
        {
            var lines = StringHelper.SplitLines(input);

            if (!lines.Any()) return Enumerable.Empty<FileDiff>();

            var files = new List<FileDiff>();
            var in_del = 0;
            var in_add = 0;

            Chunk current = null;
            FileDiff file = null;

            int oldStart, newStart;
            int oldLines, newLines;

            ParserAction start = (line, m) => {
                file = new FileDiff();
                files.Add(file);

                if (file.To == null && file.From == null)
                {
                    var fileNames = parseFile(line);

                    if (fileNames != null)
                    {
                        file.From = fileNames[0];
                        file.To = fileNames[1];
                    }
                }
            };

            ParserAction restart = (line, m) => {
                if (file == null || file.Chunks.Count != 0)
                    start(null, null);
            };

            ParserAction new_file = (line, m) => {
                restart(null, null);
                file.Type = FileChangeType.Add;
                file.From = "/dev/null";
            };

            ParserAction deleted_file = (line, m) => {
                restart(null, null);
                file.Type = FileChangeType.Delete;
                file.To = "/dev/null";
            };

            ParserAction index = (line, m) => {
                restart(null, null);
                file.Index = line.Split(' ').Skip(1);
            };

            ParserAction from_file = (line, m) => {
                restart(null, null);
                file.From = parseFileFallback(line);
            };

            ParserAction to_file = (line, m) => {
                restart(null, null);
                file.To = parseFileFallback(line);
            };

            ParserAction chunk = (line, match) => {
                in_del = oldStart = int.Parse(match.Groups[1].Value);
                oldLines = match.Groups[2].Success ? int.Parse(match.Groups[2].Value) : 0;
                in_add = newStart = int.Parse(match.Groups[3].Value);
                newLines = match.Groups[4].Success ? int.Parse(match.Groups[4].Value) : 0;
                ChunkRangeInfo rangeInfo = new ChunkRangeInfo(
                    new ChunkRange(oldStart, oldLines),
                    new ChunkRange(newStart, newLines)
                );

                current = new Chunk(line, rangeInfo);
                file.Chunks.Add(current);
            };

            ParserAction del = (line, match) => {
                string content = DiffLineHelper.GetContent(line);
                current.Changes.Add(new LineDiff(type: LineChangeType.Delete, index: in_del++, content: content));
                file.Deletions++;
            };

            ParserAction add = (line, m) => {
                string content = DiffLineHelper.GetContent(line);
                current.Changes.Add(new LineDiff(type: LineChangeType.Add, index: in_add++, content: content));
                file.Additions++;
            };

            const string noeol = "\\ No newline at end of file";

            Action<string> normal = line => {
                if (file == null) return;

                string content = DiffLineHelper.GetContent(line);
                current.Changes.Add(new LineDiff(
                    oldIndex: line == noeol ? 0 : in_del++,
                    newIndex: line == noeol ? 0 : in_add++,
                    content: content));
            };

            var schema = new Dictionary<Regex, ParserAction>
            {
                    { new Regex(@"^diff\s"), start },
                    { new Regex(@"^new file mode \d+$"), new_file },
                    { new Regex(@"^deleted file mode \d+$"), deleted_file },
                    { new Regex(@"^index\s[\da-zA-Z]+\.\.[\da-zA-Z]+(\s(\d+))?$"), index },
                    { new Regex(@"^---\s"), from_file },
                    { new Regex(@"^\+\+\+\s"), to_file },
                    { new Regex(@"^@@\s+\-(\d+),?(\d+)?\s+\+(\d+),?(\d+)?\s@@"), chunk },
                    { new Regex(@"^-"), del },
                    { new Regex(@"^\+"), add }
            };

            Func<string, bool> parse = line => {
                foreach (var p in schema)
                {
                    var m = p.Key.Match(line);
                    if (m.Success)
                    {
                        p.Value(line, m);
                        return true;
                    }
                }

                return false;
            };

            foreach (var line in lines)
                if (!parse(line))
                    normal(line);

            return files;
        }

        private static string[] parseFile(string s)
        {
            if (string.IsNullOrEmpty(s)) return null;
            return s
                .Split(' ')
                .Reverse().Take(2).Reverse()
                .Select(fileName => Regex.Replace(fileName, @"^(a|b)\/", "")).ToArray();
        }

        private static string parseFileFallback(string s)
        {
            s = s.TrimStart('-', '+');
            s = s.Trim();

            // ignore possible time stamp
            var t = new Regex(@"\t.*|\d{4}-\d\d-\d\d\s\d\d:\d\d:\d\d(.\d+)?\s(\+|-)\d\d\d\d").Match(s);
            if (t.Success)
            {
                s = s.Substring(0, t.Index).Trim();
            }

            // ignore git prefixes a/ or b/
            return Regex.IsMatch(s, @"^(a|b)\/") 
                ? s.Substring(2) 
                : s;
        }
    }
//}


// PatchHelper.cs

//namespace DiffPatch
//{
    public class PatchHelper
    {
        public static string Patch(string src, IEnumerable<Chunk> chunks)
        {
            var srcLines = StringHelper.SplitLines(src);
            var dstLines = new List<string>(srcLines);
            var srcCount = dstLines.Count;

            var trimmedDstLines = new List<string>(dstLines.Count);
            foreach (var line in dstLines)
            {
                trimmedDstLines.Add(StringHelper.RemoveLeadingWhitespace(line));
            }

            int lineIndex = 0;

            foreach (Chunk chunk in chunks)
            {
                var trimmedSearchLines = new List<string>();
                foreach (LineDiff lineDiff in chunk.Changes)
                {
                    if (lineDiff.Delete || lineDiff.Normal)
                    {
                        trimmedSearchLines.Add(StringHelper.RemoveLeadingWhitespace(lineDiff.Content));
                    }
                }

                if (trimmedSearchLines.Count > 0)
                {
                    var source = trimmedDstLines;
                    var pattern = trimmedSearchLines;

                    bool match = false;
                    bool backwards = chunk.RangeInfo.OriginalRange.StartLine + chunk.RangeInfo.OriginalRange.LineCount >= srcCount;
                    int step = backwards ? -1 : 1;
                    int start = backwards ? source.Count - pattern.Count : lineIndex;
                    int end = (backwards ? lineIndex : source.Count - pattern.Count) + step;
                    for (int i = start; i != end; i += step)
                    {
                        match = true;

                        for (int j = 0; j < pattern.Count; j++)
                        {
                            if (source[i + j] != pattern[j])
                            {
                                match = false;
                                break;
                            }
                        }

                        if (match)
                        {
                            lineIndex = i;
                            break;
                        }
                    }

                    if (!match)
                    {
                        return null;
                    }
                }

                foreach (LineDiff lineDiff in chunk.Changes)
                {
                    if (lineDiff.Add)
                    {
                        dstLines.Insert(lineIndex, lineDiff.Content);
                        trimmedDstLines.Insert(lineIndex, StringHelper.RemoveLeadingWhitespace(lineDiff.Content));
                        lineIndex++;
                    }
                    else if (lineDiff.Delete)
                    {
                        dstLines.RemoveAt(lineIndex);
                        trimmedDstLines.RemoveAt(lineIndex);
                    }
                    else if (lineDiff.Normal)
                    {
                        lineIndex++;
                    }
                }
            }

            string patchString = string.Join("\n", dstLines.ToArray());
            return patchString;
        }
    }
//}


// Data/Chunk.cs

//namespace DiffPatch.Data
//{
    public class Chunk
    {
        public Chunk(string content, ChunkRangeInfo rangeInfo)
        {
            Content = content;
            RangeInfo = rangeInfo;
            Changes = new List<LineDiff>();
        }

        public ICollection<LineDiff> Changes { get; }

        public string Content { get; }

        public ChunkRangeInfo RangeInfo { get; }
    }
//}


// Data/ChunkRange.cs

//namespace DiffPatch.Data
//{
    /// <summary>
    /// Represents the +/-s,c in a ChunkRange header (@@ -s,c +s,c @@)
    /// </summary>
    public class ChunkRange
    {
        public ChunkRange(int startLine, int lineCount)
        {
            StartLine = startLine;
            LineCount = lineCount;
        }

        /// <summary>
        /// First line of change. Non-zero indexed, first line is 1.
        /// </summary>
        public int StartLine { get; }

        /// <summary>
        /// Number of lines affected in the change. Non-zero indexed, one line addition equals 1 in this property.
        /// </summary>
        public int LineCount { get; }
    }
//}


// Data/ChunkRangeInfo.cs

//namespace DiffPatch.Data
//{
    public class ChunkRangeInfo
    {
        public ChunkRangeInfo(ChunkRange originalRange, ChunkRange newRange)
        {
            OriginalRange = originalRange;
            NewRange = newRange;
        }

        public ChunkRange OriginalRange { get; }

        public ChunkRange NewRange { get; }
    }
//}


// Data/FileChangeType.cs
//namespace DiffPatch.Data
//{
    public enum FileChangeType
    {
        Modified = 0,
        Add,
        Delete
    }
//}


// Data/FileDiff.cs

//namespace DiffPatch.Data
//{
    public class FileDiff
    {
        public ICollection<Chunk> Chunks { get; } = new List<Chunk>();

        public int Deletions { get; set; }
        public int Additions { get; set; }

        public string To { get; set; }

        public string From { get; set; }

        public FileChangeType Type { get; set; }

        public bool Deleted => Type == FileChangeType.Delete;

        public bool Add => Type == FileChangeType.Add;

        public IEnumerable<string> Index { get; set; }
    }
//}


// Data/LineChangeType.cs
//namespace DiffPatch.Data
//{
    public enum LineChangeType
    {
        Normal = 0,
        Add,
        Delete
    }
//}


// Data/LineDiff.cs
//namespace DiffPatch.Data
//{
    public class LineDiff
    {
        public LineDiff(LineChangeType type, int index, string content)
        {
            Type = type;
            Index = index;
            Content = content;
        }

        public LineDiff(int oldIndex, int newIndex, string content)
        {
            OldIndex = oldIndex;
            NewIndex = newIndex;
            Type = LineChangeType.Normal;
            Content = content;
        }

        public bool Add => Type == LineChangeType.Add;

        public bool Delete => Type == LineChangeType.Delete;

        public bool Normal => Type == LineChangeType.Normal;

        public string Content { get; }

        public int Index { get; }

        public int OldIndex { get; }

        public int NewIndex { get; }

        public LineChangeType Type { get; }
    }
//}


// StringHelper.cs

//namespace DiffPatch.Core
//{
    public static class StringHelper
    {
        private static readonly string[] newlines = new[] { "\r\n", "\n" };
        private static readonly char[] whitespace = new[] { ' ', '\t' };

        public static IEnumerable<string> SplitLines(string input)
        {
            if (string.IsNullOrWhiteSpace(input))
                return Enumerable.Empty<string>();

            string[] lines = input.Split(newlines, StringSplitOptions.None);
            return lines.Length == 0 ? Enumerable.Empty<string>() : lines;
        }

        public static string RemoveLeadingWhitespace(string line)
        {
            return line.TrimStart(whitespace);
        }
    }
//}

